{"ts":1378746360473,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":false,"ts":1378746378571,"patch":[[{"diffs":[[1,"#! /usr/bin/env python\n\"\"\"\n pyText2Pdf - Python script to convert plain text files into Adobe\n Acrobat PDF files with support for arbitrary page breaks etc.\n\n Version 2.0\n\n Author: Anand B Pillai <abpillai at gmail dot com>\n    \n\"\"\"\n\n# Derived from http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/189858\n\nimport sys, os\nimport string\nimport time\nimport optparse\nimport re\n\nLF_EXTRA=0\nLINE_END='\\015'\n# form feed character (^L)\nFF=chr(12)\n\nENCODING_STR = \"\"\"\\\n/Encoding <<\n/Differences [ 0 /.notdef /.notdef /.notdef /.notdef\n/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef\n/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef\n/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef\n/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef\n/.notdef /.notdef /.notdef /.notdef /space /exclam\n/quotedbl /numbersign /dollar /percent /ampersand\n/quoteright /parenleft /parenright /asterisk /plus /comma\n/hyphen /period /slash /zero /one /two /three /four /five\n/six /seven /eight /nine /colon /semicolon /less /equal\n/greater /question /at /A /B /C /D /E /F /G /H /I /J /K /L\n/M /N /O /P /Q /R /S /T /U /V /W /X /Y /Z /bracketleft\n/backslash /bracketright /asciicircum /underscore\n/quoteleft /a /b /c /d /e /f /g /h /i /j /k /l /m /n /o /p\n/q /r /s /t /u /v /w /x /y /z /braceleft /bar /braceright\n/asciitilde /.notdef /.notdef /.notdef /.notdef /.notdef\n/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef\n/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef\n/dotlessi /grave /acute /circumflex /tilde /macron /breve\n/dotaccent /dieresis /.notdef /ring /cedilla /.notdef\n/hungarumlaut /ogonek /caron /space /exclamdown /cent\n/sterling /currency /yen /brokenbar /section /dieresis\n/copyright /ordfeminine /guillemotleft /logicalnot /hyphen\n/registered /macron /degree /plusminus /twosuperior\n/threesuperior /acute /mu /paragraph /periodcentered\n/cedilla /onesuperior /ordmasculine /guillemotright\n/onequarter /onehalf /threequarters /questiondown /Agrave\n/Aacute /Acircumflex /Atilde /Adieresis /Aring /AE\n/Ccedilla /Egrave /Eacute /Ecircumflex /Edieresis /Igrave\n/Iacute /Icircumflex /Idieresis /Eth /Ntilde /Ograve\n/Oacute /Ocircumflex /Otilde /Odieresis /multiply /Oslash\n/Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn\n/germandbls /agrave /aacute /acircumflex /atilde /adieresis\n/aring /ae /ccedilla /egrave /eacute /ecircumflex\n/edieresis /igrave /iacute /icircumflex /idieresis /eth\n/ntilde /ograve /oacute /ocircumflex /otilde /odieresis\n/divide /oslash /ugrave /uacute /ucircumflex /udieresis\n/yacute /thorn /ydieresis ]\n>>\n\"\"\"\n\nINTRO=\"\"\"\\\n%prog [options] filename\n\nPyText2Pdf  makes a 7-bit clean PDF file from any input file.\n\nIt reads from a named file, and writes the PDF file to a file specified by\nthe user, otherwise to a file with '.pdf' appended to the input file.\n\nAuthor: Anand B Pillai.\"\"\"\n\n\nclass PyText2Pdf(object):\n    \"\"\" Text2pdf converter in pure Python \"\"\"\n    \n    def __init__(self):\n        # version number\n        self._version=\"1.3\"\n        # iso encoding flag\n        self._IsoEnc=False\n        # formfeeds flag\n        self._doFFs=False\n        self._progname=\"PyText2Pdf\"\n        self._appname = \" \".join((self._progname,str(self._version)))\n        # default font\n        self._font=\"/Courier\"\n        # default font size\n        self._ptSize=10\n        # default vert space\n        self._vertSpace=12\n        self._lines=0\n        # number of characters in a row\n        self._cols=80\n        self._columns=1\n        # page ht\n        self._pageHt=792\n        # page wd\n        self._pageWd=612\n        # input file \n        self._ifile=\"\"\n        # output file \n        self._ofile=\"\"\n        # default tab width\n        self._tab=4\n        # input file descriptor\n        self._ifs=None\n        # output file descriptor\n        self._ofs=None\n        # landscape flag\n        self._landscape=False\n        # Subject\n        self._subject = ''\n        # Author\n        self._author = ''\n        # Keywords\n        self._keywords = []\n        # Custom regexp  for page breaks\n        self._pagebreakre = None\n        \n        # marker objects\n        self._curobj = 5\n        self._pageObs = [0]\n        self._locations = [0,0,0,0,0,0]\n        self._pageNo=0\n\n        # file position marker\n        self._fpos=0\n\n    def parse_args(self):\n        \n        \"\"\" Callback function called by argument parser.\n        Helps to remove duplicate code \"\"\"\n\n        if len(sys.argv)<2:\n            sys.argv.append('-h')\n            \n        parser = optparse.OptionParser(usage=INTRO)\n        parser.add_option('-o','--output',dest='outfile',help='Direct output to file OUTFILE',metavar='OUTFILE')\n        parser.add_option('-f','--font',dest='font',help='Use Postscript font FONT (must be in standard 14, default: Courier)',\n                          default='Courier')\n        parser.add_option('-I','--isolatin',dest='isolatin',help='Use ISO latin-1 encoding',default=False,action='store_true')\n        parser.add_option('-s','--size',dest='fontsize',help='Use font at PTSIZE points (default=>10)',metavar='PTSIZE',default=10)\n        parser.add_option('-v','--linespace',dest='linespace',help='Use line spacing LINESPACE (deault 12)',metavar='LINESPACE',default=12)\n        parser.add_option('-l','--lines',dest='lines',help='Lines per page (default 60, determined automatically if unspecified)',default=60, metavar=None)\n        parser.add_option('-c','--chars',dest='chars',help='Maximum characters per line (default 80)',default=80,metavar=None)\n        parser.add_option('-t','--tab',dest='tabspace',help='Spaces per tab character (default 4)',default=4,metavar=None)\n        parser.add_option('-F','--ignoreff',dest='formfeed',help='Ignore formfeed character ^L (i.e, accept formfeed characters as pagebreaks)',default=False,action='store_true')\n        parser.add_option('-P','--papersize',dest='papersize',help='Set paper size (default is letter, accepted values are \"A4\" or \"A3\")')\n        parser.add_option('-W','--width',dest='width',help='Independent paper width in points',metavar=None,default=612)\n        parser.add_option('-H','--height',dest='height',help='Independent paper height in points',metavar=None,default=792)\n        parser.add_option('-2','--twocolumns',dest='twocolumns',help='Format as two columns',metavar=None,default=False,action='store_true')\n        parser.add_option('-L','--landscape',dest='landscape',help='Format in landscape mode',metavar=None,default=False,action='store_true')\n        parser.add_option('-R','--regexp',dest='pageregexp',help='Regular expression string to determine page breaks (if supplied, this will be used to split text into pages, instead of using line count)',metavar=None)\n        parser.add_option('-S','--subject',dest='subject',help='Optional subject for the document',metavar=None)\n        parser.add_option('-A','--author',dest='author',help='Optional author for the document',metavar=None)\n        parser.add_option('-K','--keywords',dest='keywords',help='Optional list of keywords for the document (separated by commas)',metavar=None)\n        \n\n        optlist, args = parser.parse_args()\n        # print optlist.__dict__, args\n\n        if len(args)==0:\n            sys.exit('Error: input file argument missing')\n        elif len(args)>1:\n            sys.exit('Error: Too many arguments')            \n\n        self._ifile = args[0]\n        \n        d = optlist.__dict__\n        if d.get('isolatin'): self._IsoEnc=True\n        if d.get('formfeed'): self._doFFs = True\n        if d.get('twocolumns'): self._columns = 2\n        if d.get('landscape'): self._landscape = True\n\n        self._font = '/' + d.get('font')\n        psize = d.get('papersize')\n        if psize=='A4':\n            self._pageWd=595\n            self._pageHt=842\n        elif psize=='A3':\n            self._pageWd=842\n            self._pageHt=1190\n\n        fsize = int(d.get('fontsize'))\n        if fsize < 1: fsize = 1\n        self._ptSize = fsize\n\n        lspace = int(d.get('linespace'))\n        if lspace<1: lspace = 1\n        self._vertSpace = lspace\n\n        lines = int(d.get('lines'))\n        if lines<1: lines = 1\n        self._lines = int(lines)\n\n        chars = int(d.get('chars'))\n        if chars<4: chars = 4\n        self._cols = chars\n\n        tab = int(d.get('tabspace'))\n        if tab<1: tab = 1\n        self._tab = tab\n\n        w = int(d.get('width'))\n        if w<72: w=72\n        self._pageWd = w\n\n        h = int(d.get('height'))\n        if h<72: h=72\n        self._pageHt = h\n\n        # Very optional args\n        author = d.get('author')\n        if author: self._author = author\n\n        subject = d.get('subject')\n        if subject: self._subject = subject\n\n        keywords = d.get('keywords')\n        if keywords:\n            self._keywords = keywords.split(',')\n\n        pagebreak = d.get('pageregexp')\n        if pagebreak:\n            self._pagebreakre = re.compile(pagebreak, re.UNICODE|re.IGNORECASE)\n        \n        outfile = d.get('outfile')\n        if outfile: self._ofile = outfile\n        \n        if self._landscape:\n            print 'Landscape option on...'\n        if self._columns==2:\n            print 'Printing in two columns...'\n        if self._doFFs:\n            print 'Ignoring form feed character...'\n        if self._IsoEnc:\n            print 'Using ISO Latin Encoding...'\n\n        print 'Using font',self._font[1:],'size =', self._ptSize\n\n    def writestr(self, str):\n        \"\"\" Write string to output file descriptor.\n        All output operations go through this function.\n        We keep the current file position also here\"\"\"\n\n        # update current file position\n        self._fpos += len(str)\n        for x in range(0, len(str)):\n            if str[x] == '\\n':\n                self._fpos += LF_EXTRA\n        try:\n            self._ofs.write(str)\n        except IOError, e:\n            print e\n            return -1\n\n        return 0\n            \n    def convert(self):\n        \"\"\" Perform the actual conversion \"\"\"\n    \n        if self._landscape:\n            # swap page width & height\n            tmp = self._pageHt\n            self._pageHt = self._pageWd\n            self._pageWd = tmp\n\n        if self._lines==0:\n            self._lines = (self._pageHt - 72)/self._vertSpace\n        if self._lines < 1:\n            self._lines=1\n        \n        try:\n            self._ifs=open(self._ifile)\n        except IOError, (strerror, errno):\n            print 'Error: Could not open file to read --->', self._ifile\n            sys.exit(3)\n\n        if self._ofile==\"\":\n            self._ofile = os.path.splitext(self._ifile)[0] + '.pdf'\n\n        try:\n            self._ofs = open(self._ofile, 'wb')\n        except IOError, (strerror, errno):\n            print 'Error: Could not open file to write --->', self._ofile\n            sys.exit(3)\n\n        print 'Input file=>',self._ifile\n        print 'Writing pdf file',self._ofile, '...'\n        self.writeheader()\n        self.writepages()\n        self.writerest()\n\n        print 'Wrote file', self._ofile\n        self._ifs.close()\n        self._ofs.close()\n        return 0\n\n    def writeheader(self):\n        \"\"\"Write the PDF header\"\"\"\n\n        ws = self.writestr\n\n        title = self._ifile\n        \n        t=time.localtime()\n        timestr=str(time.strftime(\"D:%Y%m%d%H%M%S\", t))\n        ws(\"%PDF-1.4\\n\")\n        self._locations[1] = self._fpos\n        ws(\"1 0 obj\\n\")\n        ws(\"<<\\n\")\n\n        buf = \"\".join((\"/Creator (\", self._appname, \" By Anand B Pillai )\\n\"))\n        ws(buf)\n        buf = \"\".join((\"/CreationDate (\", timestr, \")\\n\"))\n        ws(buf)\n        buf = \"\".join((\"/Producer (\", self._appname, \"(\\\\251 Anand B Pillai))\\n\"))\n        ws(buf)\n        if self._subject:\n            title = self._subject\n            buf = \"\".join((\"/Subject (\",self._subject,\")\\n\"))\n            ws(buf)\n        if self._author:\n            buf = \"\".join((\"/Author (\",self._author,\")\\n\"))\n            ws(buf)\n        if self._keywords:\n            buf = \"\".join((\"/Keywords (\",' '.join(self._keywords),\")\\n\"))\n            ws(buf)\n\n        if title:\n            buf = \"\".join((\"/Title (\", title, \")\\n\"))\n            ws(buf)\n\n        ws(\">>\\n\")\n        ws(\"endobj\\n\")\n    \n        self._locations[2] = self._fpos\n\n        ws(\"2 0 obj\\n\")\n        ws(\"<<\\n\")\n        ws(\"/Type /Catalog\\n\")\n        ws(\"/Pages 3 0 R\\n\")\n        ws(\">>\\n\")\n        ws(\"endobj\\n\")\n        \n        self._locations[4] = self._fpos\n        ws(\"4 0 obj\\n\")\n        ws(\"<<\\n\")\n        buf = \"\".join((\"/BaseFont \", str(self._font), \" /Encoding /WinAnsiEncoding /Name /F1 /Subtype /Type1 /Type /Font >>\\n\"))\n        ws(buf)\n    \n        if self._IsoEnc:\n            ws(ENCODING_STR)\n            \n        ws(\">>\\n\")\n        ws(\"endobj\\n\")\n        \n        self._locations[5] = self._fpos\n        \n        ws(\"5 0 obj\\n\")\n        ws(\"<<\\n\")\n        ws(\"  /Font << /F1 4 0 R >>\\n\")\n        ws(\"  /ProcSet [ /PDF /Text ]\\n\")\n        ws(\">>\\n\")\n        ws(\"endobj\\n\")\n    \n    def startpage(self):\n        \"\"\" Start a page of data \"\"\"\n\n        ws = self.writestr\n        \n        self._pageNo += 1\n        self._curobj += 1\n\n        self._locations.append(self._fpos)\n        self._locations[self._curobj]=self._fpos\n    \n        self._pageObs.append(self._curobj)\n        self._pageObs[self._pageNo] = self._curobj\n        \n        buf = \"\".join((str(self._curobj), \" 0 obj\\n\"))\n\n        ws(buf)\n        ws(\"<<\\n\")\n        ws(\"/Type /Page\\n\")\n        ws(\"/Parent 3 0 R\\n\")\n        ws(\"/Resources 5 0 R\\n\")\n\n        self._curobj += 1\n        buf = \"\".join((\"/Contents \", str(self._curobj), \" 0 R\\n\"))\n        ws(buf)\n        ws(\">>\\n\")\n        ws(\"endobj\\n\")\n        \n        self._locations.append(self._fpos)\n        self._locations[self._curobj] = self._fpos\n\n        buf = \"\".join((str(self._curobj), \" 0 obj\\n\"))\n        ws(buf)\n        ws(\"<<\\n\")\n        \n        buf = \"\".join((\"/Length \", str(self._curobj + 1), \" 0 R\\n\"))\n        ws(buf)\n        ws(\">>\\n\")\n        ws(\"stream\\n\")\n        strmPos = self._fpos\n    \n        ws(\"BT\\n\");\n        buf = \"\".join((\"/F1 \", str(self._ptSize), \" Tf\\n\"))\n        ws(buf)\n        buf = \"\".join((\"1 0 0 1 50 \", str(self._pageHt - 40), \" Tm\\n\"))\n        ws(buf)\n        buf = \"\".join((str(self._vertSpace), \" TL\\n\"))\n        ws(buf)\n    \n        return strmPos\n\n    def endpage(self, streamStart):\n        \"\"\"End a page of data \"\"\"\n        \n        ws = self.writestr\n\n        ws(\"ET\\n\")\n        streamEnd = self._fpos\n        ws(\"endstream\\n\")\n        ws(\"endobj\\n\")\n    \n        self._curobj += 1\n        self._locations.append(self._fpos)\n        self._locations[self._curobj] = self._fpos\n    \n        buf = \"\".join((str(self._curobj), \" 0 obj\\n\"))\n        ws(buf)\n        buf = \"\".join((str(streamEnd - streamStart), '\\n'))\n        ws(buf)\n        ws('endobj\\n')\n    \n    def writepages(self):\n        \"\"\"Write pages as PDF\"\"\"\n        \n        ws = self.writestr\n\n        beginstream=0\n        lineNo, charNo=0,0\n        ch, column=0,0\n        padding,i=0,0\n        atEOF=0\n        linebuf = ''\n        \n        while not atEOF:\n            beginstream = self.startpage()\n            column=1\n            \n            while column <= self._columns:\n                column += 1\n                atFF=0\n                atBOP=0\n                lineNo=0\n                # Special flag for regexp page break\n                pagebreak = False\n                \n                while lineNo < self._lines and not atFF and not atEOF and not pagebreak:\n                    linebuf = ''\n                    lineNo += 1\n                    ws(\"(\")\n                    charNo=0\n                    \n                    while charNo < self._cols:\n                        charNo += 1\n                        ch = self._ifs.read(1)\n                        cond = ((ch != '\\n') and not(ch==FF and self._doFFs) and (ch != ''))\n                        if not cond:\n                            # See if this dude matches the pagebreak regexp\n                            if self._pagebreakre and self._pagebreakre.search(linebuf.strip()):\n                                pagebreak = True\n                                \n                            linebuf = ''\n                            break\n                        else:\n                            linebuf = linebuf + ch\n\n                        if ord(ch) >= 32 and ord(ch) <= 127:\n                            if ch == '(' or ch == ')' or ch == '\\\\':\n                                ws(\"\\\\\")\n                            ws(ch)\n                        else:\n                            if ord(ch) == 9:\n                                padding =self._tab - ((charNo - 1) % self._tab)\n                                for i in range(padding):\n                                    ws(\" \")\n                                charNo += (padding -1)\n                            else:\n                                if ch != FF:\n                                    # write \\xxx form for dodgy character\n                                    buf = \"\".join(('\\\\', ch))\n                                    ws(buf)\n                                else:\n                                    # dont print anything for a FF\n                                    charNo -= 1\n\n                    ws(\")'\\n\")\n                    if ch == FF:\n                        atFF=1\n                    if lineNo == self._lines:\n                        atBOP=1\n                        \n                    if atBOP:\n                        pos=0\n                        ch = self._ifs.read(1)\n                        pos= self._ifs.tell()\n                        if ch == FF:\n                            ch = self._ifs.read(1)\n                            pos=self._ifs.tell()\n                        # python's EOF signature\n                        if ch == '':\n                            atEOF=1\n                        else:\n                            # push position back by one char\n                            self._ifs.seek(pos-1)\n\n                    elif atFF:\n                        ch = self._ifs.read(1)\n                        pos=self._ifs.tell()\n                        if ch == '':\n                            atEOF=1\n                        else:\n                            self._ifs.seek(pos-1)\n\n                if column < self._columns:\n                    buf = \"\".join((\"1 0 0 1 \",\n                                   str((self._pageWd/2 + 25)),\n                                   \" \",\n                                   str(self._pageHt - 40),\n                                   \" Tm\\n\"))\n                    ws(buf)\n\n            self.endpage(beginstream)\n\n    def writerest(self):\n        \"\"\"Finish the file\"\"\"\n\n        ws = self.writestr\n        self._locations[3] = self._fpos\n    \n        ws(\"3 0 obj\\n\")\n        ws(\"<<\\n\")\n        ws(\"/Type /Pages\\n\")\n        buf = \"\".join((\"/Count \", str(self._pageNo), \"\\n\"))\n        ws(buf)\n        buf = \"\".join((\"/MediaBox [ 0 0 \", str(self._pageWd), \" \", str(self._pageHt), \" ]\\n\"))\n        ws(buf)\n        ws(\"/Kids [ \")\n    \n        for i in range(1, self._pageNo+1):\n            buf = \"\".join((str(self._pageObs[i]), \" 0 R \"))\n            ws(buf)\n\n        ws(\"]\\n\")\n        ws(\">>\\n\")\n        ws(\"endobj\\n\")\n        \n        xref = self._fpos\n        ws(\"xref\\n\")\n        buf = \"\".join((\"0 \", str((self._curobj) + 1), \"\\n\"))\n        ws(buf)\n        buf = \"\".join((\"0000000000 65535 f \", str(LINE_END)))\n        ws(buf)\n\n        for i in range(1, self._curobj + 1):\n            val = self._locations[i]\n            buf = \"\".join((string.zfill(str(val), 10), \" 00000 n \", str(LINE_END)))\n            ws(buf)\n\n        ws(\"trailer\\n\")\n        ws(\"<<\\n\")\n        buf = \"\".join((\"/Size \", str(self._curobj + 1), \"\\n\"))\n        ws(buf)\n        ws(\"/Root 2 0 R\\n\")\n        ws(\"/Info 1 0 R\\n\")\n        ws(\">>\\n\")\n        \n        ws(\"startxref\\n\")\n        buf = \"\".join((str(xref), \"\\n\"))\n        ws(buf)\n        ws(\"%%EOF\\n\")\n        \n\ndef main():\n    \n    pdfclass=PyText2Pdf()\n    pdfclass.parse_args()\n    pdfclass.convert()\n\nif __name__ == \"__main__\":\n    main()\n"]],"start1":0,"start2":0,"length1":0,"length2":20038}]],"length":20038,"saved":false}
